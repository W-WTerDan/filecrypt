/**
 *  xor algorithm
 * 
 * xor_value(8bytes) is generated by random, and saved by xor user password.
 * saved_xor_value = (FIRST_MAGIC SECOND_MAGIC xor_value) xor (user_password_byte)
 * 
*/

#include "algs.h"

#define RANDOM_LENGTH   8
#define KEY_LENGTH  (RANDOM_LENGTH + 8)

static uint64_t get_crypt_key(file_crypt_info *crypt_info, const char *user_password) {
    int i;
    uint8_t xor_value;
    uint8_t key[RANDOM_LENGTH];

    xor_value = user_password[0];
    for (i = 1; i < strlen(user_password); i++) {
        xor_value ^= user_password[i];
    }
    memcpy(key, crypt_info->key + 8, RANDOM_LENGTH);
    for (i = 0; i < RANDOM_LENGTH; i++) {
        key[i] ^= xor_value;
    }
    return *(uint64_t *)key;
}

uint64_t xor_get_crypt_file_length(file_crypt_info *crypt_info) {
    return crypt_info->file_length;
}

/**
 *  (FIRST_MAGIC SECOND_MAGIC + xor_key) ^ (user_password_byte)
*/
uint32_t xor_is_right_password(file_crypt_info *crypt_info, const char *user_password) {

    int i;
    uint8_t xor_value;
    uint8_t key[KEY_LENGTH];
    uint32_t first_magic, second_magic;

    if (crypt_info->key_length != KEY_LENGTH) {
        return FALSE;
    }
    // calculate the user_password_byte
    xor_value = user_password[0];
    for (i = 1; i < strlen(user_password); i++) {
        xor_value ^= user_password[i];
    }
    memcpy(key, crypt_info->key, KEY_LENGTH);
    for (i = 0; i < KEY_LENGTH; i++) {
        key[i] ^= xor_value;
    }
    first_magic = *(uint32_t *) key;
    second_magic = *(uint32_t *) (key + sizeof(uint32_t));
    if (first_magic  == FIRST_MAGIC && second_magic == SECOND_MAGIC) {
        return TRUE;
    } else {
        return FALSE;
    }
}

static uint32_t xor_data(uint64_t key_value, void *input_data, void *output_data, uint64_t length) {
    int64_t i;
    uint64_t have_done = 0;
    uint64_t *in, *out;
    uint8_t *in_b, *out_b, *key_b;

    in = (uint64_t *) input_data;
    out = (uint64_t *) output_data;
    for (i = 0; i <= (int64_t)(length - RANDOM_LENGTH); i += RANDOM_LENGTH) {
        *out = *in ^ key_value;
        in++;
        out++;
        have_done += RANDOM_LENGTH;
    }
    if (have_done != length) {
        in_b = input_data + have_done;
        out_b = output_data + have_done;
        key_b = (uint8_t *) &key_value;
        for (i = 0; i < length - have_done; i++) {
            *out_b = *in_b ^ key_b[i];
            in_b++;
            out_b++;
            
        }
    }
    return TRUE;
}

uint32_t xor_encrypt(file_crypt_info *crypt_info, const char *user_password,
                     void *input_data, void *output_data) {

    int i;
    uint8_t xor_value;
    uint8_t key_buffer[KEY_LENGTH];
    uint64_t key_value;

    // xor_value generate randomly
    *(uint32_t *) &key_value = random();
    *((uint32_t *) &key_value + 1) = random();
    xor_data(key_value, input_data, output_data, crypt_info->file_length);

    *(uint32_t *) key_buffer = FIRST_MAGIC;
    *(uint32_t *) (key_buffer + sizeof(uint32_t)) = SECOND_MAGIC;
    *(uint64_t *) (key_buffer + 2 * sizeof(uint32_t)) = key_value;

    xor_value = user_password[0];
    for (i = 1; i < strlen(user_password); i++) {
        xor_value ^= user_password[i];
    }
    for (i = 0; i < KEY_LENGTH; i++) {
        key_buffer[i] ^= xor_value;
    }

    crypt_info->key_length = KEY_LENGTH;
    memcpy(crypt_info->key, key_buffer, KEY_LENGTH);
    return TRUE;
}

uint32_t xor_decrypt(file_crypt_info *crypt_info, const char *user_password,
                     void *input_data, void *output_data) {

    uint64_t key_value = get_crypt_key(crypt_info, user_password);
    xor_data(key_value, input_data, output_data, crypt_info->file_length);
    return TRUE;
}

crypt_operations xor_crypt_operations = {
    .get_crypt_file_length = xor_get_crypt_file_length,
    .is_right_password = xor_is_right_password,
    .encrypt = xor_encrypt,
    .decrypt = xor_decrypt,
};